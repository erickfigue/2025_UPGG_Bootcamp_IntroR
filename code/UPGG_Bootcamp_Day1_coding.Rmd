---
title: "UPGG Bootcamp 2025"
author: "Erick Figueroa-Ildefonso"
output: html_document
date: "2025-08-20"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Data structure

### Refresher on Data Types

We will do a quick review on data types in R. These are basically categories of values that computers can read and interpret in different ways. If you know other programming languages, these categories tend to overlap, though might have different
names.

#### 1. Numeric

Basically, numbers that we know very well. You can perform mathematical operations on them. The
types of numeric values you are going to encounter the most are:

1a. `Double` - represent real numbers (whole numbers and decimals). It is the default value for
whole numbers.

> Reminder about shortcut for making new chunk - `cmd + option + i`

```{r}
typeof(10)
typeof(20.24)
typeof(pi) # R has built-in constants, e.g., pi
```

1b. `Integer` - represent whole numbers only.

Whole numbers are defaulted to `double`. You have to tell R explicitly that a value is `integer`.

```{r}
typeof(as.integer(10))
```

You are unlikely to come across a case where `double` and `integer` will make significant changes to
your code/performance, but it's good to be aware of the different types of numeric values. Another
key point is that, arithmetic operation will automatically coerce `integer` to `double` if needs be.

```{r}
x <- as.integer(10)
typeof(x) # Will be integer
typeof(x + 10.0) # Will now be coerced to double
```

Examples of operations you can perform on numeric values.

```{r}
x <- 3 # Reminder about value assignment
y <- 4

x + y # add
x - y # subtract
x * y # multiply
x / y # divide
x ** y # exponent
x^y # exponent
x %% y # Modulo
```

**Valid variable names** There are some names you ***can't*** use as variable names, and they are
names that you ***shouldn't*** use.

1.  Start with letter

```{r, error=TRUE}
a.1 <- 5 # Will work
1.a <- 5 # Will not work
_a <- 5 # Will not work
```

2.  Don't use weird symbols, use `.` or `_`.

    Examples of style guides:

    -   [Google's](https://google.github.io/styleguide/Rguide.xml)

    -   [Jean Fan's](http://jef.works/R-style-guide/)

    -   [Tidyverse's](http://style.tidyverse.org/)

```{r, error=TRUE}
myHeightInJanuary <- "7 ft" # camelCase = first letter lowercase rest capitals
my_head_size <- "10 lbs" # Snake_case = underscores between words, all lowercase
my.value <- "None"
my$student <- "xyz" # $ has meaning in R
my-day <- "sunday" # - is for subtraction
```

3.  **DO NOT** use [reserved
    words](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html)

```{r, error=TRUE}
TRUE <- FALSE
?reserved
```

4.  Avoid naming variables the same as function names

#### 2. Logical

Sometimes these values are called `boolean` in other languages. It is common enough in programming
that you should know about! The only possible logical values are `TRUE` and `FALSE` -- case
sensitive!!!

```{r}
typeof(TRUE)
typeof(FALSE)
```

```{r}
x
y
x > y
x < y
x >= y
x <= y
x == y
x != y
!(x > y) # same as x <= y
```

> **Problem with numeric data in logical equivalence**

```{r}
10 == (sqrt(10)^2) # Why does this return FALSE?
sqrt(10)^2 # It outputs 10!!
4 == (sqrt(4)^2) # But why does this work?
sqrt(4)^2
```

Without going into the weed, an irrational number like `sqrt(10)` has infinite decimal points. So,
it is impossible for R to represent all the digits as it would take an infinite amount of storage. R
has a limited degree of `precision` that it can represent an irrational value, which makes the term
`(sqrt(10)^2)` slightly off from 10.

To circumvent this limitation, you can test for "near equality" in R using a function `all.equal()`.

```{r}
all.equal(10, sqrt(10)^2) # Yay!
```

**Logical operator**

```{r}
!TRUE # Not TRUE
TRUE & FALSE # TRUE and FALSE
TRUE | FALSE # TRUE or FALSE
TRUE | TRUE
xor(TRUE, FALSE) # either x or y, but not both
xor(TRUE, TRUE) 
```

#### 3. Character strings

Characters are created by using the `"` (double quote) or `'` (single quote) enclosing them.

```{r}
typeof('abc')
typeof("123")
letters
typeof(letters)
```

`nchar()` gives you the number of characters in the variable.

```{r}
name <- "Justin"
nchar(name)
```

Simple strings operations - joining strings using `paste()` and `paste0()` and splitting strings
using `strsplit()`.
* `paste()` automatically includes a **separator** (default being a space)
* `paste0()` doesn't include a separator

***Check whether or not they know how to see possible options for a function***

```{r}
paste(name, "Smith")
paste("Hello", "World") # returns "Hello World"
paste("Hello", "World", sep = "_")
paste0("Hi","My","Name","Is")

strsplit("Hello World", split = " ") # Get a vector of characters

```

You cannot combine two data types.

```{r, error=TRUE}
1 + "Hi"
paste("Hi", 1) # Sometimes R functions are smart enough to `coerce` types automatically when possible. Neat!
```

**Order of evaluation** Be careful if you changt type or value of a variable. Don't short-circuit
your code. Options: 1. save as new variable or 2. always run code sequentially.

```{r, error=TRUE}
x <- 1
x + 2
x <- ""
x + 2 # x is no longer numeric
```

### Vectors

A "vector" is a list of values that, importantly, are of the same type. This is the most common data
type in R.

```{r}
v1 <- c() # Empty vector
v2 <- c(1) # Vector of length 1 and of type numeric
v3 <- c("Hello", "World") # Vector of length 2 and of type character
v4 <- c(1, "hi", TRUE, 1+2) # R is smart enough to coerce the type of all element into one that can be applied to all of them -- in this case, character, designated by " marks.
print(v4)
```

Vectors have some specific properties that you can call pretty handily with built-in functions.

```{r}
# prints the type of elements contained within vector
typeof(v4)
# Prints the length of the vector
length(v4)
```

Concatenate vectors

```{r}
v5 <- c(v3, v4)
print(v5)
```

Vector arithmetic

```{r}
x <- c(1, 2, 3, 4)
x * 2
```

Vector recycling (can skip this)

```{r}
y <- c(5, 6, 7)
x + y
```

Common statistical functions

```{r}
sum(x)
min(x)
max(x)
mean(x)
median(x)
sd(x)
```

```{r}
summary(x)
```

Indexing vectors R uses the 1-based indexing system, meaning the first element begins at 1. (Python,
for example, is a zero-based indexing system.)

```{r}
x
x[1] # obtain the first element
x[-1] # obtain all but first element
x[-2] # all but second element
x[3:4] # 3rd-4th elements
x[4:1] # reverse order
rev(x)
x[1:length(x)-1] # exclude last element, flexible for any vector
x[c(TRUE,FALSE,TRUE,TRUE)] # exclude second element
```

Use indexing to manipulate content of the vector.

```{r}
y <- c(5, 6, 7)
y
y[2] <- 1999
y
```

Get indexes using `which()`

```{r}
x >= 2
which(x >= 2)
```

##### Exercise

Use what you learned about vector to return a vector containing elements within `a` that is
**greater** than 30.

```{r}
a <- runif(20, 1, 100)
```

Answer

```{r}
a[a > 30]
```

### List

List is a more flexible data type than vector - it can contain a mixture elements of various data
types. We'll breeze through this really quickly.

Creating a list

```{r}
my_list <- list("Hello", 1, TRUE) # Mixed types of element
print(my_list)
```

Size of list

```{r}
length(my_list)
```

Indexing a list using `[[]]`

```{r}
my_list[[1]]
```

Appending a list, list can even contain vector

```{r}
my_list[[5]] <- 1:10
my_list
```

Indexing

```{r}
my_list[[5]][7]
```

A list within a list

```{r}
my_list[[4]] <- list("World")
my_list
```

```{r}
my_list[[4]][[1]]
```

Combining list

```{r}
c(list(1, 2), list(x=3, y=4))
```

### Data Frame

This is arguably the most useful feature of R in data analyses. There's a reason we use
spreadsheets, they portray multi-dimentional data and its relational information between data points
across columns -- i.e., putting variables from the same observation next to each other.

Think of data frame as like a stack of vectors (each column). To be able to make sense of the data,
we want to add column names to designate what the values mean.

Creating a data frame

```{r}
df <- data.frame(1:5,
                 6:10)
df
```

```{r}
names(df)
names(df) <- c("first.column", "second.column")
names(df) # Note how codes are evaluated line-by-line sequentially?
```

Or you can add names when you create data frame.

```{r}
df2 <- data.frame(height = 100:105,
                  weight = 120:125)
df2
```

You can think of a data frame as a specialized type of `list` (with constraints), where each vector
is an element of the list. BUT the number of rows **must** be of the same length.

```{r, error=TRUE}
df3 <- data.frame(height = 100:105,
                  weight = 120:130)
```

Data frame is a **specialized** list! It has many similarities with lists.

```{r}
typeof(df)
class(df)
```

Hence, can use list-related functions.

```{r}
length(df)
df[[2]]
```

Properties of data frame

```{r}
dim(df)
ncol(df)
nrow(df)
```

Indexing, extracting information from data frame

```{r}
df[[1]] # Same as list
```

```{r}
df$first.column # Most common way to do it
```

R data frames are row-based, meaning first index refers to the row number, then column number

```{r}
df
```

```{r}
df[1,2] # row 1, column 2
```

Or, you can call by column name, and index like a normal vector.

```{r}
df$second.column[1]
```

Adding columns

```{r}
df$third <- 21:25
fourth <- runif(5, 10, 100)
df$fourth <- fourth
df
```

R has some built-in data frames that you can play with.

```{r}
mtcars
```

```{r}
iris
```

### Tibble

A `tibble` is a Tidyverse's attempt to improve on `data frame`. In general, `data frame` and `tibble` are about equivalent
in terms of function. For the sake of today and tomorrow's lesson, we'll use `tibble` because any Tidyverse's
`readr` function would output a `tibble` by default. Don't worry about the differences - they are,
for the most parts, interchangeable.

You can convert a preexisting data frame into a tibble.

```{r}
library(tidyverse)
```

```{r}
my_tib <- as_tibble(mtcars) # Converting a data frame to tibble
my_tib # looks very similar to data frame
```

Another way to create a tibble. Key components are column names and values. Each column can only
contain one data type.

```{r}
my_tib2 <- tibble(name = c("Josh", "Peter"),
                  income = c(100000000, 20))
my_tib2
```

Conventionally, for data frames and tibbles, each row contains observations, each column contains
variables, and each cell contains values.

```{r}
my_tib
```

Subsetting, same as data frame

```{r}
tb <- tibble(
  x = runif(5),
  y = rnorm(5))
# Extract by name 1
tb$x
# Extract by name 2
tb[["x"]]
# Extract by column index 1
tb[[1]]
```

```{r}
# If have time, example of differences between data frame vs tibble
mtcars[,1]
as_tibble(mtcars)[,1]
```

```{r}
class(tb)
```

## Tidyverse

What is [Tidyverse](https://www.tidyverse.org/)? Tidyverse is a collection of R packages that had
been designed and developed for data science. R is not a new language, and Tidyverse's philosophy is
about reducing redundancy and improving coding style to be cleaner and more intuitive.

Tidyverse is a literal gold mine, and there's no way we're going to cover everything in just a few
hours! We're going to go through a few functions that are particularly useful and most commonly
used.



